#!/bin/bash
set -e

# Automates wildcard ClusterIssuer, Certificate and Secret generation on a TKG cluster where cert-manager is already installed.

if [ -z "$1" ] && [ -z "$2" ] && [ -z "$3" ] && [ -z "$4" ]; then
	echo "Usage: install-mkcert-for-tkg-on-aws.sh {domain} {base64-encoded-ca-value} {base64-encoded-cert-value} {base64-encoded-key-value}"
	exit 1
fi

export DOMAIN="$1"
export BASE64_ENCODED_CA="$2"
export BASE64_ENCODED_CERT="$3"
export BASE64_ENCODED_KEY="$4"


## Create secret with existing CA and private key generated by mkcert
## This secret should be the same as the one you used with cluster provisioning and with container image registry (Harbor)
## If you're deployed Harbor in a dedicated cluster via tanzu package install, then you can harvest what you need with
##   kubectl get secret harbor-ca-key-pair -n tanzu-system-registry -o yaml

cat > ca-key-pair.yml << EOF
apiVersion: v1
data:
  ca.crt: |
    ${BASE64_ENCODED_CA}
  tls.crt: |
    ${BASE64_ENCODED_CERT}
  tls.key: |
    ${BASE64_ENCODED_KEY}
kind: Secret
metadata:
  name: ca-key-pair
  namespace: cert-manager
type: kubernetes.io/tls
EOF

kubectl apply -f ca-key-pair.yml

## Create the cluster issuer
cat << EOF | tee cluster-issuer.yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: ca-issuer
  namespace: cert-manager
spec:
  ca:
    secretName: ca-key-pair
EOF

## Install EmberStack's Reflector
### Reflector can create mirrors (of configmaps and secrets) with the same name in other namespaces automatically

kubectl -n kube-system apply -f https://github.com/emberstack/kubernetes-reflector/releases/download/v6.0.21/reflector.yaml

## Create the certificate in the contour-external namespace
cat << EOF | tee knative-tls.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: knative-tls
  namespace: contour-external
spec:
  secretTemplate:
    annotations:
      reflector.v1.k8s.emberstack.com/reflection-auto-enabled: "true"
      reflector.v1.k8s.emberstack.com/reflection-allowed: "true"
      reflector.v1.k8s.emberstack.com/reflection-allowed-namespaces: "educates"
  secretName: knative-tls
  commonName: "*.${DOMAIN}"
  dnsNames:
  - "*.${DOMAIN}"
  issuerRef:
    name: ca-issuer
    kind: ClusterIssuer
EOF


kubectl apply -f cluster-issuer.yaml
kubectl apply -f knative-tls.yaml

echo "Waiting..."
sleep 2m 30s

## If the above worked, you should get back a secret name starting with knative-tls in the contour-external namespace.  We should also see that the challenge succeeded (i.e., there should be no challenges in the namespace).
## Let's verify...

kubectl get secret -n contour-external | grep knative-tls
kubectl describe challenges -n contour-external

